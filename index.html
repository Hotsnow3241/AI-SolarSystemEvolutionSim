<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=10.0, user-scalable=yes">
    <title>2D Solar System Evolution</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Align content to top on small screens */
            min-height: 100vh;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text color */
            overflow-y: auto; /* Allow vertical scrolling on the body */
            user-select: none; /* Prevent text selection */
            -webkit-overflow-scrolling: touch; /* Enable smooth scrolling on iOS */
            padding: 1rem; /* Add some padding to the body for mobile */
            box-sizing: border-box; /* Include padding in element's total width and height */
        }
        .canvas-container { /* New container for canvas and stats */
            position: relative; /* Make this the positioning context for absolute children */
            width: 100%;
            height: 400px; /* Fixed height for the canvas container, adjust as needed */
            margin-bottom: 1.5rem; /* Keep original margin below the container */
            border-radius: 0.75rem; /* Apply rounded corners to container */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* Apply shadow to container */
            background-color: #00001a; /* Apply background to container */
        }
        canvas {
            display: block; /* Remove extra space below canvas */
            width: 100%; /* Fill the container */
            height: 100%; /* Fill the container */
            cursor: grab; /* Indicate draggable */
            /* Removed background-color, border-radius, box-shadow from canvas */
        }
        canvas:active {
            cursor: grabbing; /* Indicate dragging */
        }
        .controls-container { /* New container for all controls */
            display: flex;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            justify-content: center;
            gap: 1rem; /* Space between control groups */
            margin-bottom: 1rem;
            padding: 0 0.5rem; /* Add some padding on sides for smaller screens */
            box-sizing: border-box;
            width: 100%; /* Ensure it takes full width */
        }
        .control-group { /* Group for time and zoom controls */
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background-color: rgba(0, 0, 0, 0.4);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
        }
        button {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            font-size: 0.9rem; /* Adjust font size for better mobile readability */
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 10px -1px rgba(0, 0, 0, 0.15), 0 3px 6px -1px rgba(0, 0, 0, 0.08);
        }
        .btn-primary {
            background-color: #63b3ed; /* Blue */
            color: #1a202c;
        }
        .btn-primary:hover {
            background-color: #4299e1; /* Darker blue on hover */
        }
        .btn-secondary { /* For small +/- buttons */
            padding: 0.25rem 0.75rem;
            font-size: 0.875rem;
            border-radius: 0.375rem;
            background-color: #a0aec0;
            color: #1a202c;
        }
        .btn-secondary:hover {
            background-color: #718096;
        }
        .global-stats-bar { /* Style for the integrated global stats bar */
            background-color: rgba(0, 0, 0, 0.4);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-size: 0.8rem;
            color: #cbd5e0;
            text-align: center;
            width: 100%;
            box-sizing: border-box;
            margin-bottom: 1rem; /* Space below this bar */
            display: flex; /* Use flexbox for alignment */
            justify-content: space-around; /* Distribute items evenly */
            align-items: center;
            flex-wrap: wrap; /* Allow wrapping on small screens */
            gap: 0.5rem; /* Space between stat items */
        }
        .global-stats-bar span {
            white-space: nowrap; /* Prevent text from wrapping within a stat item */
        }
        .stats-display { /* Specific style for the dynamic stats panel on canvas */
            position: absolute; /* Position relative to the canvas-container */
            top: 1rem;
            right: 1rem;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            background-color: rgba(0, 0, 0, 0.6); /* Slightly more opaque for visibility */
            font-size: 0.75rem;
            text-align: right; /* Align text within the stats box */
            color: #e2e8f0;
            z-index: 10; /* Ensure it's above the canvas elements */
            opacity: 1;
            transition: opacity 0.3s ease-in-out;
        }
        .stats-display.hidden {
            opacity: 0;
            pointer-events: none; /* Prevent interaction when hidden */
        }
        .main-content-wrapper {
            width: 100%;
            max-width: 4xl; /* Same as the max-w-4xl on the div */
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem; /* Add padding to the main content area */
            box-sizing: border-box;
        }
        .particle-input {
            background-color: rgba(0, 0, 0, 0.4);
            border: 1px solid #4a5568;
            border-radius: 0.375rem;
            padding: 0.5rem 0.75rem;
            color: #e2e8f0;
            width: 100px; /* Fixed width for the input box */
            text-align: center;
        }
        .particle-input:focus {
            outline: none;
            border-color: #63b3ed;
            box-shadow: 0 0 0 2px rgba(99, 179, 237, 0.5);
        }

        /* Mobile-specific adjustments */
        @media (max-width: 600px) {
            body {
                justify-content: flex-start; /* Align content to top on small screens */
                padding: 0.5rem;
            }
            .main-content-wrapper {
                margin-top: 0.5rem;
                margin-bottom: 0.5rem;
                padding: 0.5rem;
            }
            .controls-container {
                flex-direction: column; /* Stack controls vertically */
                align-items: center;
                gap: 0.75rem; /* Reduce gap */
            }
            .control-group {
                width: 100%; /* Make zoom controls full width */
                justify-content: space-around; /* Distribute items evenly */
                padding: 0.75rem 0.5rem;
            }
            button {
                width: auto; /* Allow buttons to size naturally */
                padding: 0.6rem 1.2rem; /* Adjust padding */
                font-size: 0.85rem;
            }
            .global-stats-bar {
                font-size: 0.75rem; /* Smaller font for global stats on mobile */
                padding: 0.4rem 0.8rem;
            }
            .stats-display {
                top: 0.5rem;
                right: 0.5rem;
                font-size: 0.65rem;
                padding: 0.3rem 0.6rem;
            }
            h1 {
                font-size: 2rem; /* Adjust heading size */
                margin-bottom: 1rem;
            }
            p {
                font-size: 0.75rem; /* Adjust paragraph size */
            }
        }
    </style>
</head>
<body>
    <div class="main-content-wrapper p-6 bg-gray-800 rounded-xl shadow-lg mx-auto my-8">
        <h1 class="text-3xl font-bold mb-6 text-blue-300">2D Solar System Evolution</h1>
        <div class="canvas-container">
            <canvas id="solarSystemCanvas"></canvas>
            <div id="statsDisplay" class="stats-display hidden"></div>
        </div>

        <div class="controls-container">
            <div class="control-group">
                <span class="text-sm">Zoom:</span>
                <button id="zoomOutFastBtn" class="btn-secondary">--</button>
                <button id="zoomOutBtn" class="btn-secondary">-</button>
                <span id="zoomLevelDisplay" class="text-sm font-bold w-12 text-center">1.0x</span>
                <button id="zoomInBtn" class="btn-secondary">+</button>
                <button id="zoomInFastBtn" class="btn-secondary">++</button>
            </div>
            <div class="control-group">
                <label for="particleCountInput" class="text-sm">Particles:</label>
                <input type="number" id="particleCountInput" class="particle-input" value="1000" min="100" max="10000">
            </div>
            <button id="resetSimBtn" class="btn-primary">Reset Simulation</button>
            <button id="resetViewBtn" class="btn-primary">Reset View</button>
            <button id="pausePlayBtn" class="btn-primary">Pause</button>
            <button id="toggleTrackingBtn" class="btn-primary">Toggle Tracking</button>
            <div class="control-group">
                <span class="text-sm">Teleport to random:</span>
                <button id="teleportParticleBtn" class="btn-secondary">(P)</button>
                <button id="teleportClusterBtn" class="btn-secondary">(C)</button>
                <button id="teleportRandomObjectBtn" class="btn-secondary">(R)</button>
            </div>
        </div>

        <div id="globalStatsBar" class="global-stats-bar">
            <span>Simulation Time: <span id="simTimeDisplay">0</span> frames</span>
            <span>Total Particles: <span id="totalParticlesDisplay">0</span></span>
            <span>Total Clusters: <span id="totalClustersDisplay">0</span></span>
        </div>

        <p class="mt-4 text-sm text-gray-400 text-center">
            Watch as small particles orbit a central star and collide, simulating gravitational interactions.
        </p>
    </div>

    <script>
        // Get the canvas element and its 2D rendering context
        const canvas = document.getElementById('solarSystemCanvas');
        const ctx = canvas.getContext('2d');
        const resetSimBtn = document.getElementById('resetSimBtn');
        const resetViewBtn = document.getElementById('resetViewBtn');
        const simTimeDisplay = document.getElementById('simTimeDisplay');
        const totalParticlesDisplay = document.getElementById('totalParticlesDisplay');
        const totalClustersDisplay = document.getElementById('totalClustersDisplay');
        const pausePlayBtn = document.getElementById('pausePlayBtn');
        const toggleTrackingBtn = document.getElementById('toggleTrackingBtn');
        const statsDisplay = document.getElementById('statsDisplay');
        const particleCountInput = document.getElementById('particleCountInput'); // New input element

        // Teleport buttons
        const teleportParticleBtn = document.getElementById('teleportParticleBtn');
        const teleportClusterBtn = document.getElementById('teleportClusterBtn');
        const teleportRandomObjectBtn = document.getElementById('teleportRandomObjectBtn');

        // Zoom control buttons
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const zoomInFastBtn = document.getElementById('zoomInFastBtn');
        const zoomOutFastBtn = document.getElementById('zoomOutFastBtn');
        const zoomLevelDisplay = document.getElementById('zoomLevelDisplay');


        // --- Simulation Constants ---
        const G = 0.01; // Gravitational constant
        const COHESION_FORCE_G = 50.0; // Base strength of the cohesion force
        let PARTICLE_COUNT = 1000; // Now a `let` variable to be changed by user input
        const STAR_RADIUS = 25;
        const STAR_MASS = 5000; // Increased star mass for stronger gravity
        const MIN_PARTICLE_RADIUS = 1;
        const MAX_PARTICLE_RADIUS = 2.5;
        const PARTICLE_DENSITY = 0.5; // Increased particle density
        const INITIAL_DISK_INNER_RADIUS = 250; // Particles start farther out
        const INITIAL_DISK_OUTER_RADIUS = 600; // Particles start farther out
        const INITIAL_VELOCITY_FACTOR = 1; // Slightly reduced initial velocity
        const VELOCITY_NOISE = 0.001; // Random noise to initial velocity (kept low for less chaos)
        const CAMERA_MOVE_SPEED = 5; // Speed at which camera moves with WASD keys
        const CLUSTER_TOUCH_EPSILON = 0.1; // A small buffer for "touching" to ensure connectivity


        // Collision and breakup constants
        const COLLISION_DAMPENING = 0; // How much velocity is kept on collision (1=elastic, 0=inelastic/stick)
        const BREAKUP_THRESHOLD_VELOCITY_SQ = 1000; // Squared relative velocity to trigger a breakup (tune this)
        const EXPLOSION_IMPULSE_STRENGTH = 1; // Outward impulse given during breakup (tune this)
        const EXPLOSION_RADIUS_SQ = 6; // Squared radius for particles affected by explosion (tune this)

        // --- Simulation Variables ---
        let particles = []; // Array to hold all active particles (star + smaller bodies)
        let simulationTime = 0; // Tracks frames passed
        const simulationSpeed = 1.0; // Simulation speed is now constant
        let zoomLevel = 1.0; // Current zoom level (1.0 is normal)
        let cameraWorldX = 0; // World X coordinate that the camera is centered on
        let cameraWorldY = 0; // World Y coordinate that the camera is centered on
        const keys = {}; // Object to track pressed keys for camera movement

        let isDragging = false; // Flag to track mouse dragging
        let lastMouseX = 0;     // Last mouse X position for dragging
        let lastMouseY = 0;     // Last mouse Y position for dragging
        let isPaused = false;   // Simulation pause state

        let isTracking = false;   // Flag for camera tracking
        let trackedParticle = null; // Particle object to track
        let trackingOffsetX = 0; // Offset for WASD movement relative to tracked object
        let trackingOffsetY = 0; // Offset for WASD movement relative to tracked object

        // Global variables for cluster naming
        let clusterNameMap = new Map(); // Map<string (sorted particle names), string (C# name)>
        let nextClusterId = 1; // Counter for cluster IDs


        // --- Helper Functions ---

        // Calculates the distance between two particles' centers
        function distance(p1, p2) {
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // Calculates the squared distance between two particles' centers
        function distanceSq(p1, p2) {
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            return dx * dx + dy * dy;
        }

        /**
         * Finds all particles that are part of the same "cluster" as the startParticle.
         * A cluster is defined by particles touching or being within a small epsilon distance.
         * Uses a Breadth-First Search (BFS) approach.
         * @param {Particle} startParticle The particle to start the cluster search from.
         * @returns {Array<Particle>} An array of particles belonging to the same cluster.
         */
        function findCluster(startParticle) {
            if (!startParticle || !startParticle.isAlive) return [];

            const cluster = new Set(); // Use a Set to store unique particles in the cluster
            const queue = [startParticle]; // BFS queue, starting with the selected particle
            cluster.add(startParticle); // Add the starting particle to the cluster

            while (queue.length > 0) {
                const currentP = queue.shift(); // Get the next particle from the queue

                // Iterate through all active particles to find neighbors
                for (const otherP of particles) {
                    // Skip if it's the same particle, not alive, or already in the cluster
                    if (otherP.isAlive && otherP !== currentP && !cluster.has(otherP)) {
                        // Check if particles are touching or very close (within epsilon)
                        const requiredDistance = currentP.radius + otherP.radius;
                        if (distance(currentP, otherP) <= requiredDistance + CLUSTER_TOUCH_EPSILON) {
                            cluster.add(otherP); // Add to the cluster
                            queue.push(otherP); // Add to the queue for further exploration
                        }
                    }
                }
            }
            return Array.from(cluster); // Convert the Set to an Array and return
        }

        /**
         * Counts the total number of particles (excluding the sun) and identifies distinct clusters (groups of 2 or more non-star particles).
         * This function now also triggers cluster naming.
         * @returns {{totalParticles: number, clusters: Array<Array<Particle>>}} An object containing the counts and the list of clusters.
         */
        function countGlobalStats() {
            const nonStarParticles = particles.filter(p => p.isAlive && !p.isStar);
            const totalParticles = nonStarParticles.length;

            const visited = new Set();
            const allClusters = []; // Array to store actual cluster arrays

            for (const startParticle of nonStarParticles) {
                if (!visited.has(startParticle)) {
                    const currentCluster = new Set();
                    const queue = [startParticle];
                    visited.add(startParticle);
                    currentCluster.add(startParticle);

                    while (queue.length > 0) {
                        const currentP = queue.shift();

                        for (const otherP of nonStarParticles) {
                            if (otherP !== currentP && !visited.has(otherP)) {
                                const requiredDistance = currentP.radius + otherP.radius;
                                if (distance(currentP, otherP) <= requiredDistance + CLUSTER_TOUCH_EPSILON) {
                                    visited.add(otherP);
                                    currentCluster.add(otherP);
                                    queue.push(otherP);
                                }
                            }
                        }
                    }
                    // If the cluster has more than one particle, count it and add to allClusters
                    if (currentCluster.size > 1) {
                        const clusterArray = Array.from(currentCluster);
                        getClusterName(clusterArray); // Ensure this cluster gets a name
                        allClusters.push(clusterArray);
                    }
                }
            }
            return { totalParticles, totalClusters: allClusters.length, clusters: allClusters };
        }

        /**
         * Generates or retrieves a stable decimal name for a cluster.
         * @param {Array<Particle>} clusterParticles An array of particles forming the cluster.
         * @returns {string | null} The cluster name (e.g., "C1", "C2") or null if not a valid cluster.
         */
        function getClusterName(clusterParticles) {
            if (clusterParticles.length <= 1) return null; // Only name actual clusters

            // Create a stable key for the cluster based on sorted particle names
            const particleNames = clusterParticles.map(p => p.name).sort();
            const clusterKey = particleNames.join('-');

            if (clusterNameMap.has(clusterKey)) {
                return clusterNameMap.get(clusterKey);
            } else {
                const newClusterName = 'C' + nextClusterId; // Use decimal for clusters
                clusterNameMap.set(clusterKey, newClusterName);
                nextClusterId++;
                return newClusterName;
            }
        }


        // --- Particle Class Definition ---
        class Particle {
            constructor(x, y, vx, vy, radius, color, isStar = false, name = '') { // Added name parameter
                this.x = x;
                this.y = y;
                this.vx = vx; // velocity x
                this.vy = vy; // velocity y
                this.radius = radius;
                // Mass is calculated from radius for regular particles
                this.mass = radius * radius * PARTICLE_DENSITY;
                this.color = color;
                this.isStar = isStar;
                this.isAlive = true; // Flag for removal from active physics
                this.name = name; // Assign the name
            }

            // Update particle's position
            update() {
                if (!this.isAlive) return;

                // If this particle is the star, do not update its position or velocity
                if (this.isStar) {
                    this.vx = 0; // Ensure star's velocity remains 0
                    this.vy = 0;
                    return; // Skip position update for the star
                }

                // Apply current simulation speed to movement
                this.x += this.vx * simulationSpeed;
                this.y += this.vy * simulationSpeed;

                // Removed boundary check/wrap-around. Particles can now go off-screen.
            }

            // Draw the particle on the canvas
            draw() {
                if (!this.isAlive) return; // Only draw active particles

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color; // Fill the circle
                ctx.fill();

                // Draw a subtle border for larger planets (if any grow large enough)
                if (this.radius > 5) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                }
            }
        }

        // --- Core Simulation Logic ---

        // Resets camera position and zoom to initial state (used for full simulation reset)
        function resetCamera() {
            zoomLevel = 1.0;
            updateZoomLevelDisplay();
            isTracking = false;
            trackedParticle = null;
            trackingOffsetX = 0;
            trackingOffsetY = 0;
            cameraWorldX = 0; // Center camera on world (0,0)
            cameraWorldY = 0; // Center camera on world (0,0)
            toggleTrackingBtn.textContent = 'Toggle Tracking'; // Reset button text
            statsDisplay.classList.add('hidden'); // Hide dynamic stats on reset
        }

        // Resets only the view (camera position and zoom) without affecting the simulation
        function resetView() {
            zoomLevel = 1.0;
            updateZoomLevelDisplay();
            cameraWorldX = 0; // Center camera on world (0,0)
            cameraWorldY = 0; // Center camera on world (0,0)
            isTracking = false; // Turn off tracking when view is reset
            trackedParticle = null;
            trackingOffsetX = 0;
            trackingOffsetY = 0;
            toggleTrackingBtn.textContent = 'Toggle Tracking';
            statsDisplay.classList.add('hidden'); // Hide dynamic stats on view reset
        }

        // Initializes the simulation with a star and orbiting particles
        function initSimulation() {
            // Get particle count from input, validate, and set PARTICLE_COUNT
            const desiredParticleCount = parseInt(particleCountInput.value, 10);
            if (isNaN(desiredParticleCount) || desiredParticleCount < 100 || desiredParticleCount > 10000) {
                // Show a message or revert to default if input is invalid
                alert('Please enter a number between 100 and 10,000 for particle count.');
                particleCountInput.value = 1000; // Reset to default
                PARTICLE_COUNT = 1000;
            } else {
                PARTICLE_COUNT = desiredParticleCount;
            }


            particles = []; // Clear existing particles
            simulationTime = 0;
            simTimeDisplay.textContent = simulationTime;
            resetCamera(); // Reset camera on simulation reset

            isPaused = false; // Reset pause state
            pausePlayBtn.textContent = 'Pause'; // Update button text

            clusterNameMap = new Map(); // Clear cluster names on new simulation
            nextClusterId = 1; // Reset cluster ID counter

            // Create the central star at world (0,0)
            const star = new Particle(
                0, // X-coordinate
                0, // Y-coordinate
                0, 0, // Star is stationary
                STAR_RADIUS,
                '#FFFF00', // Yellow color for the star
                true, // Mark as star
                "S1" // Name the star
            );
            // Explicitly set the star's mass after creation, overriding the default calculation
            star.mass = STAR_MASS;
            particles.push(star);

            // Define color palettes
            const redGreyPalette = ['#FF0000', '#808080']; // Red and Grey
            const orangeBluePalette = ['#FFA500', '#0000FF']; // Orange and Blue

            // Create orbiting particles with random distribution within the disk, relative to (0,0)
            for (let i = 0; i < PARTICLE_COUNT; i++) { // Use the dynamic PARTICLE_COUNT
                // Random distance within the inner and outer disk radii
                const dist = INITIAL_DISK_INNER_RADIUS + Math.random() * (INITIAL_DISK_OUTER_RADIUS - INITIAL_DISK_INNER_RADIUS);
                // Random angle for full circular distribution
                const angle = Math.random() * Math.PI * 2;

                // Position relative to world (0,0)
                const x = Math.cos(angle) * dist;
                const y = Math.sin(angle) * dist;

                // Calculate initial orbital velocity for a roughly circular orbit
                // v = sqrt(G * M / r) for circular orbit
                const r_to_star = distance(star, {x: x, y: y}); // Use distance for r
                const orbitalSpeed = Math.sqrt(G * star.mass / r_to_star) * INITIAL_VELOCITY_FACTOR;

                // Velocity perpendicular to the vector from star to particle
                const dx = x - star.x; // Now star.x is 0
                const dy = y - star.y; // Now star.y is 0
                const magnitude = Math.sqrt(dx*dx + dy*dy);
                const vx_orbital = (-dy / magnitude) * orbitalSpeed;
                const vy_orbital = (dx / magnitude) * orbitalSpeed;

                // Add random deviation (noise) to velocity
                const vx_noise = (Math.random() - 0.5) * VELOCITY_NOISE;
                const vy_noise = (Math.random() - 0.5) * VELOCITY_NOISE;

                const radius = Math.random() * (MAX_PARTICLE_RADIUS - MIN_PARTICLE_RADIUS) + MIN_PARTICLE_RADIUS;

                // Determine color based on distance with a noise gradient
                let color;
                // Normalize distance to a 0-1 range based on disk radii
                let normalizedDistance = (r_to_star - INITIAL_DISK_INNER_RADIUS) / (INITIAL_DISK_OUTER_RADIUS - INITIAL_DISK_INNER_RADIUS);
                normalizedDistance = Math.max(0, Math.min(1, normalizedDistance)); // Clamp between 0 and 1

                // Probability of being orange/blue increases with distance
                // Probability of being red/grey decreases with distance
                const orangeBlueProbability = normalizedDistance; // Direct use of normalized distance
                const redGreyProbability = 1 - normalizedDistance;

                if (Math.random() < orangeBlueProbability) {
                    // Pick from orange/blue palette
                    color = orangeBluePalette[Math.floor(Math.random() * orangeBluePalette.length)];
                } else {
                    // Pick from red/grey palette
                    color = redGreyPalette[Math.floor(Math.random() * redGreyPalette.length)];
                }

                // Assign decimal name: P1, P2, ..., P(PARTICLE_COUNT)
                const particleName = 'P' + (i + 1);
                particles.push(new Particle(x, y, vx_orbital + vx_noise, vy_orbital + vy_noise, radius, color, false, particleName));
            }
        }

        // Applies gravitational forces between all particles
        function applyGravity() {
            // Apply gravity to all active particles
            const activeParticles = particles.filter(p => p.isAlive);

            for (let i = 0; i < activeParticles.length; i++) {
                for (let j = i + 1; j < activeParticles.length; j++) {
                    const p1 = activeParticles[i];
                    const p2 = activeParticles[j];

                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const r_sq = dx * dx + dy * dy; // Distance squared
                    const r = Math.sqrt(r_sq); // Actual distance

                    if (r < 1) { // Avoid division by zero or extremely strong forces at very close distances
                        continue;
                    }

                    let totalForceMagnitude = 0;

                    // Standard gravitational force (applies to all pairs)
                    const gravityForceMagnitude = G * p1.mass * p2.mass / r_sq;
                    totalForceMagnitude += gravityForceMagnitude;

                    // Cohesion force (only applies between non-star particles)
                    if (!p1.isStar && !p2.isStar) {
                        // Make cohesion force stronger when particles are closer (proportional to 1/r^8)
                        const cohesionForceMagnitude = COHESION_FORCE_G * p1.mass * p2.mass / (r_sq * r_sq * r_sq * r_sq); // r^8
                        totalForceMagnitude += cohesionForceMagnitude;
                    }

                    const angle = Math.atan2(dy, dx);
                    const fx = Math.cos(angle) * totalForceMagnitude;
                    const fy = Math.sin(angle) * totalForceMagnitude;

                    // Apply force to p1 if it's not the star, scaled by simulation speed
                    if (!p1.isStar) {
                        p1.vx += (fx / p1.mass) * simulationSpeed;
                        p1.vy += (fy / p1.mass) * simulationSpeed;
                    }
                    // Apply opposite force to p2 if it's not the star, scaled by simulation speed
                    if (!p2.isStar) {
                        p2.vx -= (fx / p2.mass) * simulationSpeed;
                        p2.vy -= (fy / p2.mass) * simulationSpeed;
                    }
                }
            }
        }

        // Handles collisions: now with dampened impacts for clumping and high-impact breakup
        function handleCollisions() {
            const activeParticles = particles.filter(p => p.isAlive);

            for (let i = 0; i < activeParticles.length; i++) {
                const p1 = activeParticles[i];
                if (!p1.isAlive) continue; // Ensure p1 is still active (could be absorbed by star in previous iteration)

                for (let j = i + 1; j < activeParticles.length; j++) {
                    const p2 = particles[j]; // Use particles[j] directly to avoid issues if activeParticles changes
                    if (!p2.isAlive) continue; // Ensure p2 is still active

                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const dist_between_centers = distance(p1, p2);

                    if (dist_between_centers < (p1.radius + p2.radius)) { // Collision detected
                        // --- Star Absorption ---
                        if (p1.isStar || p2.isStar) {
                            const absorber = p1.isStar ? p1 : p2;
                            const absorbed = p1.isStar ? p2 : p1;

                            // Ensure absorbed particle is not the star itself
                            if (!absorbed.isStar) {
                                absorber.mass += absorbed.mass; // Star's mass increases
                                absorbed.isAlive = false; // Mark absorbed particle for removal
                            }
                            continue; // Move to next pair if one was absorbed
                        }

                        // --- Particle-Particle Collision (Clumping & Breakup) ---
                        // Calculate relative velocity
                        const relVx = p2.vx - p1.vx;
                        const relVy = p2.vy - p1.vy;
                        const relVelocitySq = relVx * relVx + relVy * relVy;

                        // Collision normal vector
                        const normalX = dx / dist_between_centers;
                        const normalY = dy / dist_between_centers;

                        // Impact velocity along the normal
                        const impactVelocityAlongNormal = relVx * normalX + relVy * normalY;

                        // Separate overlapping particles slightly to prevent sticking
                        const overlap = (p1.radius + p2.radius) - dist_between_centers;
                        const separationFactor = overlap / dist_between_centers;
                        p1.x -= normalX * separationFactor * 0.5;
                        p1.y -= normalY * separationFactor * 0.5;
                        p2.x += normalX * separationFactor * 0.5;
                        p2.y += normalY * separationFactor * 0.5;


                        if (relVelocitySq > BREAKUP_THRESHOLD_VELOCITY_SQ) {
                            // --- High Impact Collision: CLUMP BREAKUP / EXPLOSION ---
                            // Apply outward impulse to colliding particles
                            p1.vx -= normalX * EXPLOSION_IMPULSE_STRENGTH / p1.mass;
                            p1.vy -= normalY * EXPLOSION_IMPULSE_STRENGTH / p1.mass;
                            p2.vx += normalX * EXPLOSION_IMPULSE_STRENGTH / p2.mass;
                            p2.vy += normalY * EXPLOSION_IMPULSE_STRENGTH / p2.mass;

                            // Affect nearby particles (simulating clump explosion)
                            const collisionCenterX = (p1.x + p2.x) / 2;
                            const collisionCenterY = (p1.y + p2.y) / 2;

                            for (let k = 0; k < activeParticles.length; k++) {
                                const p3 = activeParticles[k];
                                // Don't affect the colliding particles themselves, or already dead particles
                                if (p3 === p1 || p3 === p2 || !p3.isAlive || p3.isStar) continue;

                                const distToCollisionSq = distanceSq(p3, {x: collisionCenterX, y: collisionCenterY});
                                if (distToCollisionSq < EXPLOSION_RADIUS_SQ) {
                                    const dx3 = p3.x - collisionCenterX;
                                    const dy3 = p3.y - collisionCenterY;
                                    const dist3 = Math.sqrt(distToCollisionSq);

                                    if (dist3 > 0) { // Avoid division by zero
                                        // Impulse strength decreases with distance from collision center
                                        const impulseScale = (1 - (dist3 / Math.sqrt(EXPLOSION_RADIUS_SQ)));
                                        const impulseX = dx3 / dist3 * (EXPLOSION_IMPULSE_STRENGTH * impulseScale) / p3.mass;
                                        const impulseY = dy3 / dist3 * (EXPLOSION_IMPULSE_STRENGTH * impulseScale) / p3.mass;
                                        p3.vx += impulseX;
                                        p3.vy += impulseY;
                                    }
                                }
                            }

                        } else {
                            // --- Low Impact Collision: DAMPENED BOUNCE (Encourages Clumping) ---
                            // Calculate impulse for inelastic collision
                            const impulse = (-(1 + COLLISION_DAMPENING) * impactVelocityAlongNormal) / (1 / p1.mass + 1 / p2.mass);

                            // Apply impulse
                            p1.vx -= (impulse / p1.mass) * normalX;
                            p1.vy -= (impulse / p1.mass) * normalY;
                            p2.vx += (impulse / p2.mass) * normalX;
                            p2.vy += (impulse / p2.mass) * normalY;
                        }
                    }
                }
            }
            // Filter out particles absorbed by the star (if any)
            particles = particles.filter(p => p.isAlive);
        }

        // Function to update the zoom level display
        function updateZoomLevelDisplay() {
            zoomLevelDisplay.textContent = `${zoomLevel.toFixed(1)}x`;
        }

        /**
         * Updates the content of the stats display HTML element.
         * @param {number} objectX - The world X coordinate of the object's center.
         * @param {number} objectY - The world Y coordinate of the object's center.
         * @param {number} speed - The estimated speed of the object.
         * @param {number} rotation - The estimated rotation speed of the object in degrees per frame.
         * @param {number} mass - The total mass of the object.
         * @param {number} vx - The x-component of the object's velocity.
         * @param {number} vy - The y-component of the object's velocity.
         * @param {number} circularity - The estimated circularity of the object (0-1).
         * @param {string} objectName - The name of the tracked object (e.g., "S1", "P123", "C1").
         */
        function updateStatsDisplay(objectX, objectY, speed, rotation, mass, vx, vy, circularity, objectName) {
            const circularityPercentage = (circularity * 100).toFixed(2); // Convert to percentage
            let statsHeading = "";

            if (objectName === "S1") {
                statsHeading = "STAR STATS:";
            } else if (objectName.startsWith("P")) {
                statsHeading = "PARTICLE STATS:";
            } else if (objectName.startsWith("C")) {
                statsHeading = "CLUSTER STATS:";
            } else {
                statsHeading = "OBJECT STATS:"; // Fallback
            }

            const statsContent = `
                <div>
                    <span style="font-weight: bold;">${statsHeading}</span><br>
                    Name: ${objectName}<br>
                    Pos: (${objectX.toFixed(0)}, ${objectY.toFixed(0)})<br>
                    Vx: ${vx.toFixed(2)} Vy: ${vy.toFixed(2)}<br>
                    Speed: ${speed.toFixed(2)}<br>
                    Mass: ${mass.toFixed(2)}U<br>
                    Rotation Speed: ${rotation.toFixed(2)}°/frame<br>
                    Circularity: ${circularityPercentage}%
                </div>
            `;
            statsDisplay.innerHTML = statsContent;
        }

        /**
         * Teleports the camera to a random individual non-star particle (not part of a cluster).
         */
        function teleportToRandomParticle() {
            const nonStarParticles = particles.filter(p => p.isAlive && !p.isStar);
            const singleParticles = nonStarParticles.filter(p => findCluster(p).length === 1); // Find particles that are not part of a cluster
            
            if (singleParticles.length > 0) {
                const randomIndex = Math.floor(Math.random() * singleParticles.length);
                trackedParticle = singleParticles[randomIndex];
                isTracking = true;
                toggleTrackingBtn.textContent = 'Tracking ON';
                statsDisplay.classList.remove('hidden');

                cameraWorldX = trackedParticle.x;
                cameraWorldY = trackedParticle.y;
                trackingOffsetX = 0;
                trackingOffsetY = 0;
            } else {
                // If no single particles, try a random non-star particle as fallback, or turn off tracking
                if (nonStarParticles.length > 0) {
                    const randomIndex = Math.floor(Math.random() * nonStarParticles.length);
                    trackedParticle = nonStarParticles[randomIndex];
                    isTracking = true;
                    toggleTrackingBtn.textContent = 'Tracking ON';
                    statsDisplay.classList.remove('hidden');

                    cameraWorldX = trackedParticle.x;
                    cameraWorldY = trackedParticle.y;
                    trackingOffsetX = 0;
                    trackingOffsetY = 0;
                } else {
                    isTracking = false;
                    trackedParticle = null;
                    toggleTrackingBtn.textContent = 'Toggle Tracking';
                    statsDisplay.classList.add('hidden');
                    cameraWorldX = 0;
                    cameraWorldY = 0;
                }
            }
        }

        /**
         * Teleports the camera to the center of a random cluster (2 or more non-star particles).
         */
        function teleportToRandomCluster() {
            const { clusters } = countGlobalStats(); // Get the actual list of clusters
            if (clusters.length > 0) {
                const randomIndex = Math.floor(Math.random() * clusters.length);
                const randomCluster = clusters[randomIndex];

                // Calculate center of mass for the chosen cluster
                let sumX = 0;
                let sumY = 0;
                let totalMass = 0;
                for (const p of randomCluster) {
                    sumX += p.x * p.mass;
                    sumY += p.y * p.mass;
                    totalMass += p.mass;
                }
                const clusterCenterX = sumX / totalMass;
                const clusterCenterY = sumY / totalMass;

                // Set tracking to the first particle of this cluster (or any particle in it)
                // findCluster will then correctly identify the whole cluster for stats.
                trackedParticle = randomCluster[0];
                isTracking = true;
                toggleTrackingBtn.textContent = 'Tracking ON';
                statsDisplay.classList.remove('hidden');

                // Center camera on the cluster's center of mass
                cameraWorldX = clusterCenterX;
                cameraWorldY = clusterCenterY;
                trackingOffsetX = 0;
                trackingOffsetY = 0;
            } else {
                // If no clusters, turn off tracking
                isTracking = false;
                trackedParticle = null;
                toggleTrackingBtn.textContent = 'Toggle Tracking';
                statsDisplay.classList.add('hidden');
                cameraWorldX = 0; // Reset camera to origin
                cameraWorldY = 0;
            }
        }

        /**
         * Teleports the camera to a random active object (Star, individual particle, or cluster).
         */
        function teleportToRandomObject() {
            const star = particles.find(p => p.isStar);
            const nonStarParticles = particles.filter(p => p.isAlive && !p.isStar);
            const { clusters } = countGlobalStats();

            const trackableObjects = [];
            if (star && star.isAlive) {
                trackableObjects.push(star);
            }
            // Add individual non-clustered particles
            nonStarParticles.forEach(p => {
                if (findCluster(p).length === 1) { // Only add if it's a single particle, not part of a larger cluster
                    trackableObjects.push(p);
                }
            });
            // Add one representative particle from each cluster
            clusters.forEach(cluster => {
                if (cluster.length > 0) {
                    trackableObjects.push(cluster[0]); // Use the first particle as a representative for the cluster
                }
            });

            if (trackableObjects.length > 0) {
                const randomIndex = Math.floor(Math.random() * trackableObjects.length);
                trackedParticle = trackableObjects[randomIndex];
                isTracking = true;
                toggleTrackingBtn.textContent = 'Tracking ON';
                statsDisplay.classList.remove('hidden');

                // Center camera on the selected object/cluster's center of mass
                let targetX = trackedParticle.x;
                let targetY = trackedParticle.y;

                if (!trackedParticle.isStar && findCluster(trackedParticle).length > 1) {
                    // If it's a cluster, calculate its center of mass
                    const cluster = findCluster(trackedParticle);
                    let sumX = 0;
                    let sumY = 0;
                    let totalMass = 0;
                    for (const p of cluster) {
                        sumX += p.x * p.mass;
                        sumY += p.y * p.mass;
                        totalMass += p.mass;
                    }
                    targetX = sumX / totalMass;
                    targetY = sumY / totalMass;
                }

                cameraWorldX = targetX;
                cameraWorldY = targetY;
                trackingOffsetX = 0;
                trackingOffsetY = 0;
            } else {
                isTracking = false;
                trackedParticle = null;
                toggleTrackingBtn.textContent = 'Toggle Tracking';
                statsDisplay.classList.add('hidden');
                cameraWorldX = 0;
                cameraWorldY = 0;
            }
        }


        // Main animation loop
        function animate() {
            requestAnimationFrame(animate);

            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

            // Update global stats bar
            const { totalParticles, totalClusters } = countGlobalStats(); // This call now also names clusters
            totalParticlesDisplay.textContent = totalParticles;
            totalClustersDisplay.textContent = totalClusters;

            // Calculate cluster stats if tracking is active, regardless of pause state
            if (isTracking && trackedParticle) {
                // First, check if the tracked particle itself is still alive.
                if (!trackedParticle.isAlive) {
                    isTracking = false;
                    trackedParticle = null;
                    toggleTrackingBtn.textContent = 'Toggle Tracking';
                    statsDisplay.classList.add('hidden');
                    cameraWorldX = 0; // Recenter camera if tracking stops
                    cameraWorldY = 0;
                    return; // Stop processing tracking for this frame if particle is dead
                }

                statsDisplay.classList.remove('hidden'); // Show stats panel

                let displayObjectName = "";
                let displayObjectX = 0;
                let displayObjectY = 0;
                let displayObjectVx = 0;
                let displayObjectVy = 0;
                let displayObjectSpeed = 0;
                let displayObjectRotation = 0;
                let displayObjectMass = 0;
                let displayObjectCircularity = 1.0;

                // For circularity calculation (rotation-invariant) - Initialize here to avoid ReferenceError
                let Ixx = 0; // Sum of m*y^2
                let Iyy = 0; // Sum of m*x^2
                let Ixy = 0; // Sum of -m*x*y (product of inertia)

                if (trackedParticle.isStar) {
                    displayObjectName = trackedParticle.name; // Use the actual name "S1"
                    displayObjectX = trackedParticle.x;
                    displayObjectY = trackedParticle.y;
                    displayObjectMass = trackedParticle.mass;
                    displayObjectVx = trackedParticle.vx;
                    displayObjectVy = trackedParticle.vy;
                    displayObjectSpeed = Math.sqrt(displayObjectVx * displayObjectVx + displayObjectVy * displayObjectVy);
                    displayObjectRotation = 0; // Star doesn't rotate for this simulation
                    displayObjectCircularity = 1.0;
                } else {
                    const currentCluster = findCluster(trackedParticle);

                    if (currentCluster.length === 0) {
                        // If the non-star tracked particle is no longer found in any cluster (e.g., absorbed)
                        isTracking = false;
                        trackedParticle = null;
                        toggleTrackingBtn.textContent = 'Toggle Tracking';
                        statsDisplay.classList.add('hidden');
                        cameraWorldX = 0;
                        cameraWorldY = 0;
                        return; // Exit animate for this frame if no valid tracked particle
                    } else if (currentCluster.length === 1) { // This is the case for a single, non-star particle
                        const p = currentCluster[0];
                        displayObjectName = p.name;
                        displayObjectX = p.x;
                        displayObjectY = p.y;
                        displayObjectMass = p.mass;
                        displayObjectVx = p.vx;
                        displayObjectVy = p.vy;
                        displayObjectSpeed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
                        displayObjectRotation = 0;
                        displayObjectCircularity = 1.0;
                    } else { // Multi-particle cluster
                        displayObjectName = getClusterName(currentCluster); // Get the name for the tracked cluster

                        // Recalculate center of mass and velocity for the cluster
                        let sumX = 0;
                        let sumY = 0;
                        let sumVx = 0;
                        let sumVy = 0;
                        displayObjectMass = 0; // Reset for cluster
                        for (const p of currentCluster) {
                            sumX += p.x * p.mass;
                            sumY += p.y * p.mass;
                            sumVx += p.vx * p.mass;
                            sumVy += p.vy * p.mass;
                            displayObjectMass += p.mass;
                        }

                        displayObjectX = sumX / displayObjectMass;
                        displayObjectY = sumY / displayObjectMass;
                        displayObjectVx = sumVx / displayObjectMass;
                        displayObjectVy = sumVy / displayObjectMass;

                        // Calculate angular momentum and moment of inertia around the cluster's center of mass
                        let totalAngularMomentum = 0;
                        let effectiveMomentOfInertia = 0;
                        for (const p of currentCluster) {
                            const r_x = p.x - displayObjectX;
                            const r_y = p.y - displayObjectY;
                            const v_rel_x = p.vx - displayObjectVx;
                            const v_rel_y = p.vy - displayObjectVy;

                            // Angular momentum (2D cross product: r_x * v_y - r_y * v_x)
                            totalAngularMomentum += p.mass * (r_x * v_rel_y - r_y * v_rel_x);

                            // Moment of inertia (m * r^2)
                            effectiveMomentOfInertia += p.mass * (r_x * r_x + r_y * r_y);

                            // For rotation-invariant circularity
                            Ixx += p.mass * r_y * r_y;
                            Iyy += p.mass * r_x * r_x;
                            Ixy += -p.mass * r_x * r_y;
                        }

                        displayObjectSpeed = Math.sqrt(displayObjectVx * displayObjectVx + displayObjectVy * displayObjectVy);
                        if (effectiveMomentOfInertia > 0) {
                            const angularSpeedRad = totalAngularMomentum / effectiveMomentOfInertia; // radians per frame
                            displayObjectRotation = angularSpeedRad * (180 / Math.PI); // degrees per frame
                        }

                        if (currentCluster.length > 1 && displayObjectMass > 0) { // Only calculate for clusters with multiple particles
                            const avg_I = (Ixx + Iyy) / 2;
                            const diff_I_half = (Ixx - Iyy) / 2;
                            const sqrt_term = Math.sqrt(diff_I_half * diff_I_half + Ixy * Ixy);

                            const I1 = avg_I + sqrt_term;
                            const I2 = avg_I - sqrt_term;

                            // Circularity is the ratio of the smaller principal moment to the larger one
                            if (I1 > 0 && I2 > 0) { // Ensure non-zero moments
                                displayObjectCircularity = Math.min(I1, I2) / Math.max(I1, I2);
                            } else if (I1 === 0 && I2 === 0) {
                                displayObjectCircularity = 1.0; // Perfectly circular (e.g., single point mass)
                            } else {
                                displayObjectCircularity = 0.0; // Highly elongated or degenerate case
                            }
                        }
                    }
                }

                // Update the stats display HTML element
                updateStatsDisplay(
                    displayObjectX,
                    displayObjectY,
                    displayObjectSpeed,
                    displayObjectRotation,
                    displayObjectMass,
                    displayObjectVx,
                    displayObjectVy,
                    displayObjectCircularity,
                    displayObjectName
                );

                // Apply WASD movement only if not paused
                if (!isPaused) {
                    if (keys['w']) trackingOffsetY += CAMERA_MOVE_SPEED / zoomLevel;
                    if (keys['s']) trackingOffsetY -= CAMERA_MOVE_SPEED / zoomLevel;
                    if (keys['a']) trackingOffsetX -= CAMERA_MOVE_SPEED / zoomLevel; // Left
                    if (keys['d']) trackingOffsetX += CAMERA_MOVE_SPEED / zoomLevel; // Right

                    // Smoothly return tracking offsets to zero if keys are not pressed
                    if (!keys['w'] && !keys['s']) trackingOffsetY *= 0.9; // Decay factor
                    if (!keys['a'] && !keys['d']) trackingOffsetX *= 0.9; // Decay factor

                    // Direct assignment for camera position to remove smooth panning
                    cameraWorldX = displayObjectX + trackingOffsetX;
                    cameraWorldY = displayObjectY + trackingOffsetY;
                }


            } else {
                statsDisplay.classList.add('hidden'); // Hide stats panel when not tracking

                // Direct WASD control of cameraWorldX/Y when not tracking
                if (!isPaused) { // Only move camera if not paused
                    if (keys['w']) cameraWorldY += CAMERA_MOVE_SPEED / zoomLevel;
                    if (keys['s']) cameraWorldY -= CAMERA_MOVE_SPEED / zoomLevel;
                    if (keys['a']) cameraWorldX -= CAMERA_MOVE_SPEED / zoomLevel; // Left
                    if (keys['d']) cameraWorldX += CAMERA_MOVE_SPEED / zoomLevel; // Right
                }
            }

            // Only update physics and particle positions if not paused
            if (!isPaused) {
                applyGravity(); // Calculate and apply gravitational forces
                handleCollisions(); // Handle collisions (dampened bounce or breakup)

                // Update particle positions (already scaled by simulationSpeed inside Particle.update)
                particles.forEach(p => {
                    p.update();
                });

                simulationTime++;
                simTimeDisplay.textContent = simulationTime;
            }

            // Always draw particles, even when paused, so the view doesn't disappear
            ctx.save();
            // Apply transformations: translate to center, scale, then translate to camera's world center
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(zoomLevel, zoomLevel);
            ctx.translate(-cameraWorldX, -cameraWorldY); // Move the camera's world center to the canvas origin

            particles.forEach(p => p.draw());

            // Draw tracking indicator if tracking is on and a particle is tracked
            if (isTracking && trackedParticle) {
                const currentCluster = findCluster(trackedParticle);
                // Initialize with trackedParticle's position; if cluster is empty, this is still valid
                let clusterCenterX = trackedParticle.x;
                let clusterCenterY = trackedParticle.y;
                let clusterMinX = trackedParticle.x - trackedParticle.radius;
                let clusterMaxX = trackedParticle.x + trackedParticle.radius;
                // Initialize clusterMinY and clusterMaxY here
                let clusterMinY = trackedParticle.y - trackedParticle.radius;
                let clusterMaxY = trackedParticle.y + trackedParticle.radius;

                if (currentCluster.length > 0) {
                    // Recalculate center of mass for drawing the circle
                    let sumX = 0;
                    let sumY = 0;
                    let totalMass = 0;
                    for (const p of currentCluster) {
                        sumX += p.x * p.mass;
                        sumY += p.y * p.mass;
                        totalMass += p.mass;

                        clusterMinX = Math.min(clusterMinX, p.x - p.radius);
                        clusterMaxX = Math.max(clusterMaxX, p.x + p.radius);
                        clusterMinY = Math.min(clusterMinY, p.y - p.radius);
                        clusterMaxY = Math.max(clusterMaxY, p.y + p.radius);
                    }
                    clusterCenterX = sumX / totalMass;
                    clusterCenterY = sumY / totalMass;
                }

                ctx.strokeStyle = '#00FF00'; // Green outline
                ctx.lineWidth = 1; // Made thinner

                // Calculate radius of the circle that encloses the cluster's bounding box
                const boundingBoxWidth = clusterMaxX - clusterMinX;
                const boundingBoxHeight = clusterMaxY - clusterMinY;
                const trackingCircleRadius = Math.sqrt(boundingBoxWidth * boundingBoxWidth + boundingBoxHeight * boundingBoxHeight) / 2 + 5; // Half of diagonal + padding

                ctx.beginPath();
                ctx.arc(clusterCenterX, clusterCenterY, trackingCircleRadius, 0, Math.PI * 2);
                ctx.stroke();
            }

            ctx.restore(); // Restore context to default (no zoom/pan)
        }

        // --- Event Listeners and Initialization ---

        // Adjust canvas size to fit its container and handle window resizing
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            // No need to redraw particles here as animate loop handles it
        }

        resetSimBtn.addEventListener('click', initSimulation);
        resetViewBtn.addEventListener('click', resetView); // Event listener for the new button

        // Event listener for the new pause/play button
        pausePlayBtn.addEventListener('click', () => {
            isPaused = !isPaused; // Toggle the pause state
            pausePlayBtn.textContent = isPaused ? 'Play' : 'Pause'; // Update button text
        });

        // Event listeners for new teleport buttons
        teleportParticleBtn.addEventListener('click', teleportToRandomParticle);
        teleportClusterBtn.addEventListener('click', teleportToRandomCluster);
        teleportRandomObjectBtn.addEventListener('click', teleportToRandomObject);


        // Event listener for clicking on a particle to track it
        canvas.addEventListener('click', (event) => {
            const rect = canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;

            // Convert click coordinates from canvas space to world space
            // This calculation needs to reverse the transformations applied in animate()
            // current_canvas_x = (world_x - cameraWorldX) * zoomLevel + canvas.width / 2
            // Rearranging for world_x:
            const worldClickX = (clickX - canvas.width / 2) / zoomLevel + cameraWorldX;
            const worldClickY = (clickY - canvas.height / 2) / zoomLevel + cameraWorldY;

            // Find the particle that was clicked
            let clickedParticle = null;
            for (const p of particles) {
                const distFromClickToParticleCenterSq = distanceSq({x: worldClickX, y: worldClickY}, p);
                if (distFromClickToParticleCenterSq <= p.radius * p.radius) {
                    clickedParticle = p;
                    break;
                }
            }

            if (clickedParticle) {
                // If the clicked particle is already tracked, untrack it.
                // Otherwise, track it.
                if (isTracking && trackedParticle === clickedParticle) {
                    isTracking = false;
                    trackedParticle = null;
                    toggleTrackingBtn.textContent = 'Toggle Tracking';
                    // When untracking, reset camera to center on world (0,0)
                    cameraWorldX = 0;
                    cameraWorldY = 0;
                    statsDisplay.classList.add('hidden'); // Hide stats
                } else {
                    trackedParticle = clickedParticle;
                    isTracking = true;
                    toggleTrackingBtn.textContent = 'Tracking ON';
                    statsDisplay.classList.remove('hidden'); // Show stats

                    // Immediately center camera on the cluster's center of mass
                    // If it's a single particle, findCluster will return just that particle
                    const initialCluster = findCluster(trackedParticle);
                    let initialClusterCenterX = clickedParticle.x;
                    let initialClusterCenterY = clickedParticle.y;

                    if (initialCluster.length > 0) {
                        let sumX = 0;
                        let sumY = 0;
                        let totalMass = 0;
                        for (const p of initialCluster) {
                            sumX += p.x * p.mass;
                            sumY += p.y * p.mass;
                            totalMass += p.mass;
                        }
                        initialClusterCenterX = sumX / totalMass;
                        initialClusterCenterY = sumY / totalMass;
                    }
                    cameraWorldX = initialClusterCenterX;
                    cameraWorldY = initialClusterCenterY;
                }

                // Reset tracking offsets so any immediate WASD input starts from centered
                trackingOffsetX = 0;
                trackingOffsetY = 0;
            } else {
                // If no particle was clicked, turn tracking off
                isTracking = false;
                trackedParticle = null;
                toggleTrackingBtn.textContent = 'Toggle Tracking';
                trackingOffsetX = 0;
                trackingOffsetY = 0;
                statsDisplay.classList.add('hidden'); // Hide stats
            }
        });

        // Toggle tracking button (for general on/off, clicking on particle overrides)
        toggleTrackingBtn.addEventListener('click', () => {
            isTracking = !isTracking; // Toggle tracking state
            toggleTrackingBtn.textContent = isTracking ? 'Tracking ON' : 'Toggle Tracking'; // Update button text
            // When tracking is toggled off, clear the tracked particle and reset offsets
            if (!isTracking) {
                trackedParticle = null; // No particle tracked when tracking is off
                trackingOffsetX = 0;
                trackingOffsetY = 0;
                // When untracking via button, reset camera to center on world (0,0)
                cameraWorldX = 0;
                cameraWorldY = 0;
                statsDisplay.classList.add('hidden'); // Hide stats
            } else {
                // If tracking is turned ON via button, and no particle was previously tracked,
                // default to tracking the star.
                if (!trackedParticle) {
                    trackedParticle = particles.find(p => p.isStar);
                    if (trackedParticle) {
                        cameraWorldX = trackedParticle.x; // Should be 0
                        cameraWorldY = trackedParticle.y; // Should be 0
                    }
                }
                statsDisplay.classList.remove('hidden'); // Show stats
            }
        });


        // Event listeners for zoom controls
        zoomOutBtn.addEventListener('click', () => {
            zoomLevel = Math.max(0.2, zoomLevel - 0.1); // Minimum zoom 0.2x
            updateZoomLevelDisplay();
        });
        zoomInBtn.addEventListener('click', () => {
            zoomLevel = Math.min(20.0, zoomLevel + 0.1); // Maximum zoom increased to 20.0x
            updateZoomLevelDisplay();
        });
        zoomOutFastBtn.addEventListener('click', () => { // New fast zoom out
            zoomLevel = Math.max(0.2, zoomLevel - 1.0);
            updateZoomLevelDisplay();
        });
        zoomInFastBtn.addEventListener('click', () => { // New fast zoom in
            zoomLevel = Math.min(20.0, zoomLevel + 1.0); // Maximum zoom increased to 20.0x
            updateZoomLevelDisplay();
        });

        // Mouse wheel for zooming
        canvas.addEventListener('wheel', (event) => {
            event.preventDefault(); // Prevent page scrolling
            const zoomAmount = event.deltaY * -0.001; // Invert direction, scale amount
            zoomLevel = Math.max(0.2, Math.min(20.0, zoomLevel + zoomAmount)); // Maximum zoom increased to 20.0x
            updateZoomLevelDisplay();
        });

        // Mouse events for dragging/panning
        canvas.addEventListener('mousedown', (event) => {
            // Only activate dragging if it's a single touch/mouse click
            if (event.touches && event.touches.length > 1) return; // Ignore multi-touch for single-finger drag
            isDragging = true;
            lastMouseX = event.clientX || event.touches[0].clientX;
            lastMouseY = event.clientY || event.touches[0].clientY;
            canvas.style.cursor = 'grabbing';
        });

        canvas.addEventListener('mousemove', (event) => {
            if (isDragging) {
                // Only process if it's a single touch/mouse click
                if (event.touches && event.touches.length > 1) {
                    isDragging = false; // Stop dragging if multi-touch detected during move
                    return;
                }
                const currentX = event.clientX || event.touches[0].clientX;
                const currentY = event.clientY || event.touches[0].clientY;

                const dx = currentX - lastMouseX;
                const dy = currentY - lastMouseY;

                // Adjust cameraWorldX/Y based on mouse movement and current zoom level
                // Mouse/touch movement in canvas pixels needs to be converted to world units
                cameraWorldX -= dx / zoomLevel;
                cameraWorldY -= dy / zoomLevel;

                lastMouseX = currentX;
                lastMouseY = currentY;
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            canvas.style.cursor = 'grab';
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            canvas.style.cursor = 'grab';
        });

        // --- Touch Events for Pinch Zoom and Pan ---
        let initialPinchDistance = 0;
        let initialZoomLevel = 1.0;
        let lastCenter = { x: 0, y: 0 };

        canvas.addEventListener('touchstart', (event) => {
            if (event.touches.length === 2) {
                event.preventDefault(); // Prevent scrolling/default behavior when two fingers are used
                isDragging = false; // Disable single-finger drag when pinch starts

                // Calculate initial pinch distance
                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                initialPinchDistance = Math.sqrt(dx * dx + dy * dy);
                initialZoomLevel = zoomLevel;

                // Calculate initial center of the two touches for panning
                lastCenter.x = (event.touches[0].clientX + event.touches[1].clientX) / 2;
                lastCenter.y = (event.touches[0].clientY + event.touches[1].clientY) / 2;

            } else if (event.touches.length === 1) {
                // For single touch, allow it to be handled by mousedown/mousemove if needed for panning
                // (though touch-action: pan-x pan-y will handle it natively)
                isDragging = true;
                lastMouseX = event.touches[0].clientX;
                lastMouseY = event.touches[0].clientY;
            }
        }, { passive: false }); // Use passive: false to allow preventDefault

        canvas.addEventListener('touchmove', (event) => {
            if (isDragging && event.touches.length === 1) { // Only for single touch drag
                const currentX = event.touches[0].clientX;
                const currentY = event.touches[0].clientY;

                const dx = currentX - lastMouseX;
                const dy = currentY - lastMouseY;

                cameraWorldX -= dx / zoomLevel;
                cameraWorldY -= dy / zoomLevel;

                lastMouseX = currentX;
                lastMouseY = currentY;
            } else if (event.touches.length === 2) {
                event.preventDefault(); // Prevent scrolling/default behavior during pinch-zoom/pan
                isDragging = false; // Ensure single-finger drag is off during pinch

                // Calculate current pinch distance
                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                const currentPinchDistance = Math.sqrt(dx * dx + dy * dy);

                // Calculate zoom factor
                if (initialPinchDistance > 0) {
                    const zoomFactor = currentPinchDistance / initialPinchDistance;
                    zoomLevel = Math.max(0.2, Math.min(20.0, initialZoomLevel * zoomFactor));
                    updateZoomLevelDisplay();
                }

                // Calculate center for two-finger pan
                const currentCenterX = (event.touches[0].clientX + event.touches[1].clientX) / 2;
                const currentCenterY = (event.touches[0].clientY + event.touches[1].clientY) / 2;

                const panDx = currentCenterX - lastCenter.x;
                const panDy = currentCenterY - lastCenter.y;

                // Adjust cameraWorldX/Y based on two-finger pan
                cameraWorldX -= panDx / zoomLevel;
                cameraWorldY -= panDy / zoomLevel;

                lastCenter.x = currentCenterX;
                lastCenter.y = currentCenterY;

            }
        }, { passive: false }); // Use passive: false to allow preventDefault

        canvas.addEventListener('touchend', (event) => {
            // Reset pinch state
            initialPinchDistance = 0;
            isDragging = false; // Reset single-finger drag
        });
        canvas.addEventListener('touchcancel', (event) => {
            // Reset pinch state
            initialPinchDistance = 0;
            isDragging = false; // Reset single-finger drag
        });


        // Keyboard event listeners for WASD camera movement
        window.addEventListener('keydown', (event) => {
            keys[event.key.toLowerCase()] = true;
        });
        window.addEventListener('keyup', (event) => {
            keys[event.key.toLowerCase()] = false;
        });


        // Initial setup on window load
        window.onload = function() {
            resizeCanvas(); // Set initial canvas size and populate the simulation
            initSimulation(); // Initialize the simulation
            animate(); // Start the animation loop
        };

        // Listen for window resize events to keep canvas responsive
        window.addEventListener('resize', resizeCanvas);

    </script>
</body>
</html>
